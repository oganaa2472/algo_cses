#include <iostream>
#include <vector>
#include <algorithm>

const int mod = 1e9 + 7;

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n; // n: зоосны тоо
    int x; // x: зорилтот нийлбэр
    std::cin >> n >> x;

    std::vector<int> coins(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> coins[i];
    }

    // DP хүснэгт (массив). dp[j] нь j нийлбэрийг үүсгэх боломжит замын тоо.
    // Хэмжээ нь x + 1 (0-ээс x хүртэлх нийлбэрүүд).
    // Эхлээд бүгдийг 0-ээр эхлүүлнэ.
    std::vector<int> dp(x + 1, 0);

    // Үндсэн нөхцөл: 0 нийлбэрийг үүсгэх нэг зам бий (ямар ч зоос ашиглахгүй).
    dp[0] = 1;

    // Табюлацийн процесс: Зоосуудаар давталт хийж, нийлбэрүүдийг шинэчилнэ.
    // Энэ давталтын дараалал нь эрэмбэ хамаарахгүйг тоолоход чухал.
    for (int coin : coins) { // Зоос бүрээр (гаднах давталт)
        // Тухайн зоосыг ашиглан үүсгэх боломжит нийлбэрүүдээр давталт хийнэ.
        // coin-ийн утгаас эхэлнэ, учир нь түүнээс бага нийлбэрт энэ зоос дангаараа хүрч чадахгүй.
        for (int sum = coin; sum <= x; sum++) {
            // DP шилжилт: j нийлбэрийг үүсгэх замын тоог шинэчилнэ.
            // dp[sum] = (dp[sum] + dp[sum - coin]) % mod;
            // Одоогийн dp[sum] нь тухайн зоосыг ашиглаагүй эсвэл өмнөх зоосоор үүсгэсэн замуудын тоог агуулна.
            // dp[sum - coin] нь тухайн зоосыг нэмэхээс өмнөх нийлбэр (sum - coin)-ийг
            // одоог хүртэл авч үзсэн зоосуудыг ашиглан үүсгэсэн замын тоог агуулна.
            // Энэ хоёрыг нэмснээр тухайн зоосыг ашигласан болон ашиглаагүй бүх замыг тоолно.
            dp[sum] = (dp[sum] + dp[sum - coin]) % mod;
        }
    }

    // Эцсийн хариу нь x нийлбэрийг үүсгэх замын тоо буюу dp[x] байна.
    std::cout << dp[x] << std::endl;

    return 0;
}