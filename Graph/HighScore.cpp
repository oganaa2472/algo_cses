#include <iostream>
#include <vector>
#include <limits>
#include <tuple>

// Хязгааргүй их зайг илэрхийлэх утга.
// Бид хамгийн богино замыг олохдоо оноог сөрөг болгосон тул
// хязгааргүй их оноо нь урвуулсан график дээрх хязгааргүй бага зай болно.
// long long-ийн хамгийн их утгыг эхлүүлэх зай болгоход ашиглана.
const long long INF = std::numeric_limits<long long>::max();

// Графикийн ирмэг (хонгил)-ийг илэрхийлэх бүтэц
struct Edge {
    int to; // Очих өрөө
    long long weight; // Хонгилоор дамжих үеийн онооны өөрчлөлт (сөрөг утгаар хадгална)
};

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n, m; // n: өрөөний тоо, m: хонгилын тоо
    std::cin >> n >> m;

    // Графикийг хадгалах, adjacency list ашиглана.
    // adj[u] нь u өрөөнөөс гарч буй ирмэгүүдийн жагсаалт.
    std::vector<std::vector<Edge>> adj(n + 1);
    // Беллман-Фордын давталтад бүх ирмэгийг хурдан ашиглахын тулд
    // ирмэгүүдийн жагсаалтыг хадгална.
    std::vector<std::tuple<int, int, long long>> edges;

    // Оролтын хонгилуудыг уншиж, графикт нэмнэ.
    // Хамгийн урт замыг олохын тулд оноог сөрөг болгож хадгална.
    for (int i = 0; i < m; ++i) {
        int u, v, w;
        std::cin >> u >> v >> w;
        adj[u].push_back({v, -w}); // Оноог сөрөг болгож хадгална.
        edges.emplace_back(u, v, -w); // Ирмэгийн жагсаалтад нэмнэ.
    }

    // dist[i] нь 1-р өрөөнөөс i-р өрөөнд хүрэх хамгийн богино зам (урвуулсан оноогоор).
    std::vector<long long> dist(n + 1, INF);
    dist[1] = 0; // 1-р өрөөнд хүрэх зай (өөртөө) 0.

    // Беллман-Фордын алгоритм
    // N өрөөтэй графикт сөрөг давталт байхгүй бол N-1 удаагийн давталтаар хамгийн богино зам олдоно.
    // Бид энд N удаа давтана, учир нь N дахь давталтыг сөрөг давталтыг илрүүлэхэд ашиглана.
    for (int i = 0; i < n; ++i) {
        for (const auto& edge : edges) {
            int u, v;
            long long w;
            std::tie(u, v, w) = edge; // Ирмэгийн мэдээллийг задална.

            // Хэрэв u өрөөнд хүрэх зам хязгааргүй биш бөгөөд u-ээс v рүү явах нь v-д хүрэх зайг багасгаж байвал
            // dist[u] != INF шалгалт нь хязгааргүйгээс нэмэх үед халихгүй байхад тусална.
            if (dist[u] != INF && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w; // Зайг шинэчилнэ.

                // Хэрэв энэ N дахь давталт (индекс нь n-1 байна) бөгөөд зай шинэчлэгдэж байвал
                // урвуулсан график дээр сөрөг давталт байна гэсэн үг.
                // Хэрэв 1-р өрөөнөөс хүрч болох эерэг оноотой давталт байгаа бол оноо хязгааргүй болно.
                // Энэ тохиолдолд бодлогын дагуу -1 хэвлэнэ.
                if (i == n - 1) {
                    std::cout << -1 << std::endl;
                    return 0; // Програмыг зогсооно.
                }
            }
        }
    }

    // Хэрэв N удаа давталтын дараа (N дахь давталтад зай шинэчлэгдээгүй бол),
    // 1-р өрөөнөөс N-р өрөөнд хүрэх хамгийн их оноог тооцно.
    // Хамгийн их оноо нь урвуулсан график дээрх хамгийн богино зайн утгын эсрэг тэмдэгтэй тэнцүү.
    // Өгөгдөлд 1-ээс N-д хүрч болно гэсэн тул dist[n] нь INF байхгүй.
    std::cout << -dist[n] << std::endl;

    return 0;
}