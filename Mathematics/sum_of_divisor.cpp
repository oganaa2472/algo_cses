#include <iostream> // Оролт гаралтын стандарт сан
#include <vector>   // Вектор ашиглах (энэ бодлогод шууд хэрэг болохгүй ч нийтлэг)
#include <numeric>  // std::gcd (энэ бодлогод хэрэг болохгүй ч нийтлэг)
#include <algorithm> // std::max, std::min гэх мэт (энэ бодлогод хэрэг болохгүй ч нийтлэг)

// std namespace-ийг ашигласнаар std::-г бичих шаардлагагүй болно.
using namespace std;

int main() {
    // n - оролтын тоо. Нийлбэрийг 1-ээс n хүртэлх sigma(i)-ийн нийлбэрийг олно.
    long long n;
    cin >> n;

    // Модуло. Бодлогод 10^9 + 7 гэж өгөгдсөн.
    long long MOD = 1e9 + 7;

    // 2-ын модуло MOD-ээрх урвуу.
    // (MOD нь анхны тоо тул (MOD + 1) / 2 нь 2-ын модуло MOD-ээрх урвуу болно).
    long long inv2 = (MOD + 1) / 2;

    // Нийт нийлбэр sigma(i)-ийн нийлбэрийг хадгалах хувьсагч.
    long long total_sum = 0;

    // Нийлбэрийг sum(d * floor(n/d)) = sum(k * sum(d)) хэлбэрээр тооцоолно.
    // floor(n/d) нь 'k' гэсэн тогтмол утгатай байх d-ийн завсруудаар давталт хийнэ.
    // 'i' нь одоогийн авч үзэж буй d-ийн завсрын эхлэлийг заана.
    for (long long i = 1; i <= n; ) {
        // Одоогийн завсар дахь floor(n / d) утгыг тооцоолох.
        // Энэ утга нь i-ийн хувьд floor(n / i) байна.
        long long k = n / i; // k = floor(n / i)

        // Одоогийн завсар (floor(n / d) == k байх d-ийн завсар)-ын төгсгөлийг олох.
        // d = floor(n / k) нь floor(n / d) == k байх хамгийн их d юм.
        long long next_i = n / k;

        // Одоогийн авч үзэж буй d-ийн завсар бол [i, next_i].
        // Энэ завсар дахь бүх d-ийн хувьд floor(n / d) нь k-тэй тэнцүү.
        // Энэ завсрын нийлбэрт оруулах хувь нэмэр нь:
        // k * (i-ээс next_i хүртэлх d-ийн нийлбэр)

        // i-ээс next_i хүртэлх тоонуудын нийлбэрийг арифметик цувааны томьёогоор олох:
        // Нийлбэр = (эхлэл + төгсгөл) * (элементийн тоо) / 2
        // Эхлэл = i, Төгсгөл = next_i, Элементийн тоо = next_i - i + 1
        // Бүх үйлдлүүдийг МОДУЛОГООР хийнэ.

        long long first_term = i % MOD;
        long long last_term = next_i % MOD;
        long long num_terms = (next_i - i + 1) % MOD;

        // (i + next_i) * (next_i - i + 1) / 2 модуло MOD тооцоолох.
        // Сөрөг утга гарахгүйн тулд хасах үйлдэл дээр МОДУЛО НЭМНЭ.
        // num_terms = (next_i % MOD - i % MOD + MOD) % MOD; // Энэ ч бас боломжтой, гэхдээ дээрх хасахгүй учраас аюулгүй.

        // ((эхлэл + төгсгөл) % MOD * элементийн тоо % MOD) % MOD * inv2 % MOD
        long long sum_d_mod = ( (first_term + last_term) % MOD * num_terms % MOD ) % MOD;
        sum_d_mod = (sum_d_mod * inv2) % MOD; // 2-т хуваах нь inv2-ээр үржүүлэхтэй ижил.

        // Энэ завсрын нийлбэрт оруулах хувь нэмэр: k * (i-ээс next_i хүртэлх d-ийн нийлбэр)
        long long segment_contribution = (k % MOD * sum_d_mod) % MOD;

        // Нийт нийлбэрт нэмэх (нэмэхдээ мөн МОДУЛОГООР).
        total_sum = (total_sum + segment_contribution) % MOD;

        // Дараагийн давталтыг шинэ завсрын эхлэлээс эхлүүлэхийн тулд 'i'-г шинэчлэх.
        i = next_i + 1;
    }

    // Эцсийн нийлбэрийг хэвлэх.
    cout << total_sum << endl;

    return 0;
}