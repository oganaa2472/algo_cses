#include <iostream> // Стандарт оролт/гаралтын сан
#include <vector>   // Вектор ашиглах
#include <numeric>  // std::gcd (хэдий үндсэн алгоритмд ашиглаагүй ч, холбоотой)
#include <algorithm> // std::max ашиглах

// std namespace-ийг ашигласнаар std::-г бичих шаардлагагүй болно.
using namespace std;

// Оролтын тоонуудын хамгийн их боломжит утга.
// Хязгаарлалтаас 10^6 байна.
const int MAX_VAL = 1000000; // 10^6

// Оролтын массив доторх тоо тус бүр хэдэн удаа давтагдсаныг хадгалах массив.
// counts[i] нь 'i' гэсэн тоо оролтонд хэдэн удаа байсныг заана.
// Глобалаар зарлавал автоматаар 0-ээр эхэлнэ.
int counts[MAX_VAL + 1];

int main() {
    // Оролт/гаралтыг хурдасгах тохиргоо.
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n; // Оролтын массивын хэмжээ (тоонуудын тоо)
    cin >> n;

    int max_val_in_input = 0; // Оролтын массив доторх хамгийн их утгыг олох хувьсагч

    // Оролтын n тоог уншиж, тэдгээрийн давтамжийг 'counts' массивт бүртгэнэ.
    // Мөн оролтын тоонуудын хамгийн их утгыг олно.
    for (int i = 0; i < n; ++i) {
        int a; // Оролтын тоо
        cin >> a;
        counts[a]++; // 'a' гэсэн тооны давтамжийг нэгээр нэмэгдүүлнэ.
        max_val_in_input = max(max_val_in_input, a); // Оролт доторх хамгийн их утгыг шинэчилнэ.
    }

    // Алгоритм: Боломжит хамгийн их хос хосын GCD-ийн утгуудыг
    // оролтын хамгийн их утгаас эхлэн 1 хүртэл багасгах дарааллаар шалгах.
    // Хамгийн анх, оролтын массив дотор ядаж хоёр үржвэртэй байх тэр 'g' утга нь хариу болно.
    for (int g = max_val_in_input; g >= 1; --g) {
        int multiples_count = 0; // 'g' гэсэн тоонд хуваагддаг оролтын тоонуудын тоог тоолох

        // 'g'-ийн үржвэрүүдийг (g, 2*g, 3*g, ...) оролтын хамгийн их утга (max_val_in_input) хүртэл шалгана.
        // multiple нь g-ээс эхлэнэ.
        for (int multiple = g; multiple <= max_val_in_input; multiple += g) {
             // 'g'-ийн үржвэр болох 'multiple' гэсэн тоо оролтын массив дотор
             // хэдэн удаа давтагдсаныг (counts[multiple])-г 'multiples_count'-тай нэмнэ.
             multiples_count += counts[multiple];

             // Оптимизац: Хэрэв 'g'-ийн үржвэрүүд оролтонд нийт ядаж 2 удаа таарвал,
             // энэ 'g' нь боломжит GCD мөн тул цааш үржвэр шалгах шаардлагагүй.
             if (multiples_count >= 2) {
                 break; // Доторх давталтыг зогсооно.
             }
        }

        // Хэрэв 'g'-д хуваагддаг оролтын тоонуудын нийт тоо 2 ба түүнээс их байвал,
        // 'g' нь массив доторх ядаж хоёр тооны нийтлэг хуваагч болж чадна.
        // Бид 'g'-г ихээс нь шалгаж байгаа тул, анх энэ нөхцөл биелсэн үеийн 'g' нь
        // бидний хайж буй хамгийн их хос хосын GCD болно.
        if (multiples_count >= 2) {
            cout << g << endl; // Хамгийн их хос хосын GCD-г хэвлэнэ.
            return 0; // Програмыг амжилттай дуусгана.
        }
    }

    // Хэрэв оролтын массивын хэмжээ n < 2 байвал энд хүрч болно.
    // Уралдаант бодлогын хязгаарлалтаас n >= 2 байдаг тул энэ хэсэг хэзээ ч ажиллахгүй.
    return 0;
}